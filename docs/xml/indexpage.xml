<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>&lt;a href=&quot;http://dismech.github.io/&quot;&gt;DisMech: A Discrete Differential Geometry-based Physical Simulator for Soft Robots and Structures&lt;/a&gt;</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="index_1md__home_radha_Desktop_dismech_rods_main_README"/>  <table rows="3" cols="2"><row>
<entry thead="no" align="center"><para><image type="html" name="media/dismech-logo.jpg" inline="yes"></image>
 <linebreak/>
 <emphasis>Logo </emphasis>  </para>
</entry><entry thead="no" align="center"><para><image type="html" name="media/spider_incline.gif" inline="yes"></image>
 <linebreak/>
 <emphasis>Spider robot dropped onto an incline </emphasis> </para>
<para></para>
<para></para>
</entry></row>
<row>
<entry thead="no" align="center" rowspan="2"><para><image type="html" name="media/active_entanglement_cropped.gif" inline="yes"></image>
 <linebreak/>
 <emphasis> Active entanglement gripper </emphasis>  </para>
</entry><entry thead="no" align="center"><para><image type="html" name="media/helix.gif" inline="yes"></image>
 <linebreak/>
 <emphasis> Helix oscillating under gravity </emphasis>   </para>
</entry></row>
<row>
<entry thead="no" align="center"><para><image type="html" name="media/real2sim.gif" inline="yes"></image>
 <linebreak/>
 <emphasis> Real2Sim soft manipulator modelling </emphasis>   </para>
</entry></row>
</table>
</para>
<para><ulink url="http://dismech.github.io/">DisMech</ulink> is a discrete differential geometry-based physical simulator for elastic rod-like structures and soft robots. Based on the <ulink url="https://www.cs.columbia.edu/cg/pdfs/143-rods.pdf">Discrete Elastic Rods</ulink> framework, it can be used to simulate soft structures for a wide variety of purposes such as robotic deformable material manipulation and soft robot control.</para>
<para><hruler/>
</para>
<sect2 id="index_1autotoc_md1">
<title>TODO</title>
<para>If you&apos;d like DisMech to support a new feature, feel free create an issue and we&apos;ll add it to the list here.</para>
<sect3 id="index_1autotoc_md2">
<title>High priority</title>
<para><itemizedlist>
<listitem><para>[ ] Add per-limb friction coefficient logic. PR <ulink url="https://github.com/StructuresComp/dismech-rods/pull/5">#5</ulink></para>
</listitem><listitem><para>[ ] Add active entanglement example code.</para>
</listitem><listitem><para>[ ] Add limb self-contact option.</para>
</listitem><listitem><para>[ ] Add contact logic for joints.</para>
</listitem><listitem><para>[ ] Add URDF functionality for instantiating robot.</para>
</listitem></itemizedlist>
</para>
</sect3>
<sect3 id="index_1autotoc_md3">
<title>Low priority</title>
<para><itemizedlist>
<listitem><para>[ ] Possibly replace floor contact force (currently uses IMC) with modified mass method.</para>
</listitem><listitem><para>[ ] Add detailed documentation for all examples.</para>
</listitem><listitem><para>[ ] Add more code examples for initializing limbs and joints.</para>
</listitem><listitem><para>[ ] Add time varying boundary condition logic.</para>
</listitem><listitem><para>[ ] Add more controller types.</para>
</listitem><listitem><para>[ ] Add shell functionality.</para>
</listitem></itemizedlist>
</para>
</sect3>
</sect2>
<sect2 id="index_1autotoc_md4">
<title>COMPLETED</title>
<para><itemizedlist>
<listitem><para>[x] Add forward Euler integration scheme.</para>
</listitem><listitem><para>[x] Add contact logic for limbs. <hruler/>
</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect2 id="index_1autotoc_md5">
<title>Dependencies</title>
<para>There are some dependencies required prior to compilation. Instructions for macOS and Ubuntu are similar (presented below). For other operating systems you should be able to modify the commands below appropriately.</para>
<para><itemizedlist>
<listitem><para><bold>macOS</bold>: Because this uses the MKL, it&apos;s not certain to run on Apple silicone.</para>
</listitem><listitem><para><bold>macOS</bold>: If you&apos;re running a mac, it&apos;s highly recommended you use a package manager like <ulink url="https://www.macports.org/install.php">MacPorts</ulink> or <ulink url="https://brew.sh/">homebrew</ulink>. Instructions below are for MacPorts.</para>
</listitem><listitem><para><bold>Note</bold>: Some of these packages are installed to the system library for convenience. You may want to install locally to e.g., <computeroutput>~/.local</computeroutput> to avoid conflicts with system libraries. Add the <computeroutput>cmake</computeroutput> flag: <computeroutput>-D CMAKE_INSTALL_PREFIX=~/.local</computeroutput>. Then <computeroutput>sudo</computeroutput> is not required to install. You&apos;ll need to ensure subsequent builds know where to find the build libraries.</para>
</listitem><listitem><para>X11<itemizedlist>
<listitem><para>An X11 (xorg) server is necessary to use the <computeroutput>freeglut</computeroutput> library. This exists already on Linux.</para>
</listitem><listitem><para><bold>macOS</bold>: This can be installed with MacPorts: <computeroutput>sudo port install xorg-server</computeroutput>. Then log out and back in.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen 3.4.0</ulink><itemizedlist>
<listitem><para>Eigen is used for various linear algebra operations.</para>
</listitem><listitem><para><bold>macOS</bold>: You can install this version with MacPorts: <computeroutput>sudo port install eigen3</computeroutput>. Otherwise, build instructions are below.</para>
</listitem><listitem><para>DisMech is built with Eigen version 3.4.0 which can be downloaded <ulink url="https://gitlab.com/libeigen/eigen/-/releases/3.4.0">here</ulink>. After downloading the source code, install through cmake as follows. ```bash cd eigen-3.4.0 &amp;&amp; mkdir build &amp;&amp; cd build cmake .. sudo make install ```</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="https://github.com/flexible-collision-library/fcl">Flexible Collision Library (FCL)</ulink><itemizedlist>
<listitem><para>The FCL library is used to perform both broadphase and narrowphase collision detection with each discrete rod represented as a chain of cylinders.</para>
</listitem><listitem><para>FCL depends on both Eigen (instructions above) and <ulink url="https://github.com/danfis/libccd">libccd</ulink>. Install <ulink url="https://github.com/danfis/libccd">libccd</ulink> with the following commands: ```bash git clone <ulink url="https://github.com/danfis/libccd">https://github.com/danfis/libccd</ulink> cd libccd/src make -j4 sudo make install ```</para>
</listitem><listitem><para>Next, install FCL from source using the following commands: ```bash git clone <ulink url="https://github.com/flexible-collision-library/fcl">https://github.com/flexible-collision-library/fcl</ulink> cd fcl &amp;&amp; mkdir build &amp;&amp; cd build cmake .. make -j4 sudo make install ```</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="https://github.com/symengine/symengine">SymEngine</ulink><itemizedlist>
<listitem><para>SymEngine is used for symbolic differentiation and function generation.</para>
</listitem><listitem><para><bold>macOS</bold>: SymEngine with LLVM can be installed with MacPorts: <computeroutput>sudo port install symengine</computeroutput>.</para>
</listitem><listitem><para>Before installing SymEngine, LLVM is required which can be installed most easily via a package manager:<itemizedlist>
<listitem><para><bold>Ubuntu</bold>: <computeroutput>sudo apt-get install llvm</computeroutput></para>
</listitem><listitem><para><bold>macOS</bold>: <computeroutput>sudo port install llvm-15</computeroutput></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Afterwards, install SymEngine from source using the following commands: ```bash git clone <ulink url="https://github.com/symengine/symengine">https://github.com/symengine/symengine</ulink> cd symengine &amp;&amp; mkdir build &amp;&amp; cd build cmake -D WITH_LLVM=on -D BUILD_BENCHMARKS=off -D BUILD_TESTS=off .. make -j4 sudo make install ``<computeroutput></computeroutput></para>
</listitem><listitem><para><computeroutput>**macOS**: You&apos;ll need to provide the LLVM root to the build with</computeroutput>-D CMAKE_PREFIX_PATH=/opt/local/libexec/llvm-15` (if installed via MacPorts).</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-download.html?operatingsystem=linux&amp;distributions=webdownload&amp;options=online">Intel oneAPI Math Kernel Library (oneMKL)</ulink><itemizedlist>
<listitem><para>Necessary for access to Pardiso, which is used as a sparse matrix solver.</para>
</listitem><listitem><para>Intel MKL is also used as the BLAS / LAPACK backend for Eigen.</para>
</listitem><listitem><para><bold>macOS</bold>: Download from <ulink url="https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-download.html">Intel</ulink> and use the install script.</para>
</listitem><listitem><para><bold>Ubuntu</bold>: Follow the below steps. ```bash cd /tmp wget <ulink url="https://registrationcenter-download.intel.com/akdlm/irc_nas/18483/l_onemkl_p_2022.0.2.136.sh">https://registrationcenter-download.intel.com/akdlm/irc_nas/18483/l_onemkl_p_2022.0.2.136.sh</ulink></para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</sect2>
<sect1 id="index_1autotoc_md6">
<title>This runs an installer, simply follow the instructions.</title>
<para>sudo sh ./l_onemkl_p_2022.0.2.136.sh ```<itemizedlist>
<listitem><para>Add the following to your .bashrc. Change the directory accordingly if your MKL version is different. ```bash export MKLROOT=/opt/intel/oneapi/mkl/2022.0.2 ```</para>
</listitem></itemizedlist>
</para>
<para><ulink url="https://www.opengl.org/">OpenGL / GLUT</ulink><itemizedlist>
<listitem><para>OpenGL / GLUT is used for rendering the knot through a simple graphic.</para>
</listitem><listitem><para>Simply install through apt package manager:<itemizedlist>
<listitem><para><bold>Ubuntu</bold>: <computeroutput>sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev</computeroutput></para>
</listitem><listitem><para><bold>macOS</bold>: <computeroutput>sudo port install freeglut pkgconfig</computeroutput> (Note: <computeroutput>pkgconfig</computeroutput> is necessary to avoid finding system GLUT instead of <computeroutput>freeglut</computeroutput>.)</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para>Lapack (<emphasis>included in MKL</emphasis>)</para>
<para><hruler/>
</para>
<sect3 id="index_1autotoc_md7">
<title>Running Examples</title>
<para>DisMech is setup so that simulation environments can be instantiated using a single cpp file called <computeroutput><ref refid="robotDescription_8cpp" kindref="compound">robotDescription.cpp</ref></computeroutput>.</para>
<para>Several example of working DisMech simulations can be seen in the <computeroutput>examples/</computeroutput> directory. In order to run an example, copy the example cpp file into the main directory and then compile DisMech. For example, using the cantilever beam example:</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">cp<sp/>examples/cantilever_case/cantileverExample.cpp<sp/>robotDescription.cpp</highlight></codeline>
<codeline><highlight class="normal">mkdir<sp/>build<sp/>&amp;&amp;<sp/>cd<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cmake<sp/>..</highlight></codeline>
<codeline><highlight class="normal">make<sp/>-j4</highlight></codeline>
<codeline><highlight class="normal">cd<sp/>..</highlight></codeline>
</programlisting> Afterwards, simply run the simulation using the <computeroutput>dismech.sh</computeroutput> script. <programlisting filename=".bash"><codeline><highlight class="normal">./dismech.sh</highlight></codeline>
</programlisting> If you want to run another example, simply replace the <computeroutput><ref refid="robotDescription_8cpp" kindref="compound">robotDescription.cpp</ref></computeroutput> file and recompile.</para>
<para><hruler/>
</para>
</sect3>
<sect3 id="index_1autotoc_md8">
<title>Creating Custom Simulation Environments</title>
<para>In case you want to create a custom simulation environment, take a look at the provided examples on how to do so.</para>
<para>Simulation parameters such as defining the soft structure(s) / robot(s), boundary conditions, forces, and logging are done solely in <computeroutput><ref refid="robotDescription_8cpp" kindref="compound">robotDescription.cpp</ref></computeroutput> so that large recompiles do not take place.</para>
<para>In addition, many numerical parameters can be set through the <computeroutput><ref refid="structsimParams" kindref="compound">simParams</ref></computeroutput> struct shown below with default values and descriptions. Note that parameters with a <computeroutput>*</computeroutput> have additional explanations below. Parameters with a <computeroutput>^</computeroutput> only apply when an implicit numerical integration scheme is chosen and are otherwise ignored. <programlisting><codeline><highlight class="normal"><sp/>{c++}</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>simParams<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>sim_time<sp/>=<sp/>10;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Total<sp/>time<sp/>for<sp/>simulation<sp/>[s]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>dt<sp/>=<sp/>1e-3;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Time<sp/>step<sp/>size<sp/>[s]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>render<sp/>=<sp/>true;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Live<sp/>OpenGL<sp/>rendering</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>show_mat_frames<sp/>=<sp/>false;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Render<sp/>material<sp/>frames</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>render_scale<sp/>=<sp/>1.0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Rendering<sp/>scale</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>dtol<sp/>=<sp/>1e-2;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>*^<sp/>Dynamics<sp/>tolerance<sp/>[m/s]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>ftol<sp/>=<sp/>1e-4;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>*^<sp/>Force<sp/>tolerance</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>max_iter<sp/>=<sp/>500;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>^<sp/><sp/>Maximum<sp/>iterations<sp/>for<sp/>a<sp/>time<sp/>step</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>adaptive_time_stepping<sp/>=<sp/>0;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>*^<sp/>Adaptive<sp/>time<sp/>stepping</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>cmd_line_per<sp/>=<sp/>1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Command<sp/>line<sp/>sim<sp/>info<sp/>output<sp/>period</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>enable_2d_sim<sp/>=<sp/>false;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Lock<sp/>z<sp/>and<sp/>theta<sp/>DOFs</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>bool<sp/>line_search<sp/>=<sp/>true;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>^<sp/><sp/>Enable<sp/>line<sp/>search<sp/>method</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numerical_integration_scheme<sp/>nis<sp/>=<sp/>BACKWARD_EULER;<sp/>//<sp/>*<sp/><sp/>Numerical<sp/>integration<sp/>scheme<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>debug_verbosity<sp/>=<sp/>1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/><sp/><sp/><sp/>Prints<sp/>certain<sp/>debug<sp/>statements<sp/></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>Detailed parameter explanations:</para>
<para><itemizedlist>
<listitem><para><computeroutput>numerical_integration_scheme</computeroutput> - Determines the numerical integration scheme. Currently, available options are<itemizedlist>
<listitem><para><computeroutput>FORWARD_EULER</computeroutput>: <ulink url="https://en.wikipedia.org/wiki/Euler_method">https://en.wikipedia.org/wiki/Euler_method</ulink></para>
</listitem><listitem><para><computeroutput>VERLET_POSITION</computeroutput>: <ulink url="https://en.wikipedia.org/wiki/Verlet_integration">https://en.wikipedia.org/wiki/Verlet_integration</ulink></para>
</listitem><listitem><para><computeroutput>BACKWARD_EULER</computeroutput>: <ulink url="https://en.wikipedia.org/wiki/Backward_Euler_method">https://en.wikipedia.org/wiki/Backward_Euler_method</ulink></para>
</listitem><listitem><para><computeroutput>IMPLICIT_MIDPOINT</computeroutput>: <ulink url="https://en.wikipedia.org/wiki/Midpoint_method">https://en.wikipedia.org/wiki/Midpoint_method</ulink></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>dtol</computeroutput> - A dynamics tolerance. Considers Newton&apos;s method to converge if the infinity norm of the DOF update divided by time step size for Cartesian positions is less than <computeroutput>dtol</computeroutput>: $$\frac{|| \Delta \mathbf q ||_{\infty}} {\Delta t} &lt; \textrm{dtol}$$ Note that we ignore $\theta$ DOFs due to difference in scaling.</para>
</listitem><listitem><para><computeroutput>ftol</computeroutput> - A force tolerance. Considers Newton&apos;s method to converge if the cumulative force norm becomes less than the starting force norm * <computeroutput>ftol</computeroutput>. $$|| \mathbf f || &lt; || \mathbf f_0 || * \textrm{ftol}$$</para>
</listitem><listitem><para><computeroutput>adaptive_time_stepping</computeroutput> - Turns on adaptive time stepping which halves the time step size if failure to converge after set number of iterations. Set to 0 to disable.</para>
</listitem></itemizedlist>
</para>
<para><hruler/>
 </para>
</sect3>
<sect3 id="index_1autotoc_md9">
<title>Citation</title>
<para>If our work has helped your research, please cite the following paper. <programlisting><codeline><highlight class="normal">@misc{choi2023dismech,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>title={DisMech:<sp/>A<sp/>Discrete<sp/>Differential<sp/>Geometry-based<sp/>Physical<sp/>Simulator<sp/>for<sp/>Soft<sp/>Robots<sp/>and<sp/>Structures},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>author={Andrew<sp/>Choi<sp/>and<sp/>Ran<sp/>Jing<sp/>and<sp/>Andrew<sp/>Sabelhaus<sp/>and<sp/>Mohammad<sp/>Khalid<sp/>Jawed},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>year={2023},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>eprint={2311.18126},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>archivePrefix={arXiv},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>primaryClass={cs.RO}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><hruler/>
 </para>
</sect3>
<sect3 id="index_1autotoc_md10">
<title>Acknowledgements</title>
<para>This material is based upon work supported by the National Science Foundation. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation. </para>
</sect3>
</sect1>
    </detaileddescription>
    <location file="/home/radha/Desktop/dismech-rods-main/README.md"/>
  </compounddef>
</doxygen>
